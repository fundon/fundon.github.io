<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Node on Fangdun Cai</title>
    <link>https://fundon.me/tags/node/</link>
    <description>Recent content in Node on Fangdun Cai</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2015, Fangdun Cai; all rights reserved.</copyright>
    <lastBuildDate>Thu, 15 Sep 2016 00:15:46 +0800</lastBuildDate>
    <atom:link href="https://fundon.me/tags/node/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ES6 QuickStart and Tips</title>
      <link>https://fundon.me/blog/ES6-QuickStart-and-Tips/</link>
      <pubDate>Thu, 15 Sep 2016 00:15:46 +0800</pubDate>
      
      <guid>https://fundon.me/blog/ES6-QuickStart-and-Tips/</guid>
      <description>

&lt;h1 id=&#34;es6-quickstart-and-tips&#34;&gt;ES6: QuickStart and Tips&lt;/h1&gt;

&lt;p&gt;ES6: 快速体验，及实用小贴士&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2016 年是 ES6 大力推广和普及的黄金时期，也是今年的流行趋势，
就一个 &lt;a href=&#34;https://github.com/search?o=desc&amp;amp;q=ES6&amp;amp;s=stars&amp;amp;type=Repositories&amp;amp;utf8=✓&#34;&gt;ES6&lt;/a&gt; 关键词，
在 GitHub 上就有这么多搜索结果。（赶紧跟上大部队！）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/fundon/ES6-QuickStart-and-Tips/blob/master/images/github-search-results.png?raw=true&#34; alt=&#34;It&#39;s very hot!&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;ES6 是 &lt;strong&gt;ECMAScript 6&lt;/strong&gt; 的简称，是 &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/index.html&#34;&gt;ECMA-262 的第 6 版本&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ES5、ES2015 / ES6、ES2016 / ES7、ES2017 / ES8 这些关键词具体代表什么？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_5_support_in_Mozilla&#34;&gt;ES5&lt;/a&gt; 发布于 2009 年。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla&#34;&gt;ES6&lt;/a&gt;，比起 ES5，是第一个大版本更新，在 2015-06 发布，所以又称 ES2015。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_Next_support_in_Mozilla&#34;&gt;ES7 和 ES8&lt;/a&gt; 统称为 ECMAScript Next。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* [ES7] 在 2016-06 发布，又称 ES2016。

* ES8 在 2017-06 发布，又称 ES2017。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ECMAScript 与 JavaScript 有什么关系？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者是后者的语言标准，后者是前者的一个实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ES6 在浏览器，Node.js 支持如何，适不适合开发，生产？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器： &lt;a href=&#34;http://kangax.github.io/compat-table/es6/&#34;&gt;ECMAScript 兼容列表&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Node.js：&lt;a href=&#34;http://node.green&#34;&gt;ES2015 Support&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工具：使用一些转换工具，可以把 ES6 =&amp;gt; ES5&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么要学习新语法？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前很多库、框架、工具都在使用 &lt;strong&gt;ES6+&lt;/strong&gt; 进行开发，典型的就是 React 和 Vue，使用新语法特性的优势进行快速开发，然后使用转换构建工具部署生产代码。&lt;/p&gt;

&lt;h2 id=&#34;es6-新特性&#34;&gt;ES6 新特性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Arrows and Lexical This&lt;/p&gt;

&lt;p&gt;「箭头」函数（&lt;code&gt;=&amp;gt;&lt;/code&gt;）和 &lt;code&gt;this&lt;/code&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使用「箭头」函数我们可以体验函数式编程的”美”，高效、简洁，当然也要注意上下文 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  var sum = function (a, b) { return a + b }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  var sum = (a, b) =&amp;gt; a + b
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;a.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var PI = 3.14

var c = r =&amp;gt; 2 * PI * r

// c(2) = ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;b.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var PI = 3.14

var circle = {
  PI: 3.14159,
  c: r =&amp;gt; 2 * this.PI * r
}

// circle.c(2) = ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;c.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var PI = 3.14

var circle = {
  PI: 3.14159,
  c (r) {
    return 2 * this.PI * r
  }
}

// circle.c(2) = ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Classes&lt;/p&gt;

&lt;p&gt;类：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;基于原型链的语法糖，简单、清晰；面向对象编程更加轻松。&lt;br /&gt;
再也不会被其他语言吐槽了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  function Cat () {
    this.voice = &#39;miao&#39;
  }
  Cat.prototype.speak = function () {
    console.log(this.voice)
  }

  function Lion () {
    this.voice = &#39;roar&#39;
  }

  Lion.prototype = Cat.prototype

  var c = new Cat()
  var l = new Lion()
  c.speak()
  l.speak()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  class Cat {
    constructor () {
      this.voice = &#39;miao&#39;
    }

    speak () {
      console.log(this.voice)
    }
  }

  class Lion extends Cat {
    constructor () {
      super()

      this.voice = &#39;roar&#39;
    }
  }
  var c = new Cat()
  var l = new Lion()
  c.speak()
  l.speak()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;cat.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Cat {
  constructor () {
    this.voice = &#39;miao&#39;
  }

  speak () {
    console.log(this.voice)
  }

  static type () {
    return Cat.name.toLowercase()
  }
}

// Cat.prototype= ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;getters-setters.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Cat {
  constructor (options) {
    this.voice = &#39;miao&#39;
    this.options = options || {}
  }

  speak () {
    console.log(this.voice)
  }

  get name () {
    return this.options.name
  }

  set name (name) {
    this.options.name = name
  }
}

var a = new Cat({ name: &#39;Garfield&#39; })
// a.name ?
// a.name = &#39;Tom&#39;
// a.name ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&#34;&gt;mixins.js&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CalculatorMixin = Base =&amp;gt; class extends Base {
  calc() { }
}

var RandomizerMixin = Base =&amp;gt; class extends Base {
  randomize() { }
}

class Foo { }
class Bar extends CalculatorMixin(RandomizerMixin(Foo)) { }

// Bar.prototype ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Enhanced Object Literals&lt;/p&gt;

&lt;p&gt;改进对象声明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大大减少了代码量，创建对象更加简洁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性缩写&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数缩写&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;属性名计算&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  var a = 1
  var b = 2
  var c = 3

  var o = {
    a: a,
    b: b
    c: c,
    d: function () {
      return this.a + this.b + this.c
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  var o = {
    a,
    b,
    c,
    d () {
      return this.a + this.b + this.c
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;returns.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var generate = (name, age) =&amp;gt; ({ name, age })

// generate(&#39;github&#39;, 5) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;cumputed-properties.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var create = (path, verb) =&amp;gt; {
  return {
    path,
    verb,
    [&#39;is&#39; + verb[0].toUpperCase() + verb.substring(1)]: true
  }
}

// create(&#39;/&#39;, &#39;get&#39;) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;complicated.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var path = &#39;/&#39;
var verb = &#39;get&#39;
var root = {
  path,
  verb
}

var route = {
  root
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Template Strings&lt;/p&gt;

&lt;p&gt;模板字符串：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;终于可以舒服的写多行字符串了，这功能等到花儿都谢了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持多行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持变量绑定&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也支持对字符串不转义，不解析&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  var first = 1
  var second = 2
  var third = 3

  var str = &#39;No.&#39; + first + &#39;\n&#39; +
    &#39;No.&#39; + second +&#39;\n&#39; +
    &#39;No.&#39; + third
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  var first = 1
  var second = 2
  var third = 3

  var str = `No. ${first}
  No. ${second}
  No. ${third}
  `
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;raw-tag.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var t0 = `In ES5 &amp;quot;\n&amp;quot; is a line-feed.`
var t1 = String.raw`In ES5 &amp;quot;\n&amp;quot; is a line-feed.`

// console.log(t0)
// console.log(t1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;expression.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = 5
var b = 10

// console.log(&amp;quot;Fifteen is &amp;quot; + (a + b) + &amp;quot; and\nnot &amp;quot; + (2 * a + b) + &amp;quot;.&amp;quot;)
// console.log(`Fifteen is ${a + b} and\nnot ${2 * a + b}.`)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;custom-tag.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var generatePath = (strings, ...values) =&amp;gt; {
  return strings[0] + values.reduce((prev, curr) =&amp;gt; `${prev}/${curr}`, &#39;&#39;)
}

var user = &#39;user&#39;
var id = &#39;233&#39;
var profile = &#39;profile&#39;
// generatePath`GET: ${user}${id}${profile}`
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Destructuring&lt;/p&gt;

&lt;p&gt;解析赋值&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;可以轻松获取对象、数组等的元素，并赋值到指定变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Array ArrayLike Object 等，具有迭代器接口的对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  var arr = [1, 2, 3, 4]

  var a0 = arr[0]
  var a1 = arr[1]
  var a2 = arr[2]

  var obj = {
    name: &#39;github&#39;,
    age: 5
  }

  var name = obj.name
  var age = obj.age
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  var arr = [1, 2, 3, 4]

  var [a0, a1, a2] = arr

  var obj = {
    name: &#39;github&#39;,
    age: 5
  }

  var { name, age } = obj
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;print.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var print = ({ name, age }) =&amp;gt; console.log(name, age)

// print({ name: &#39;ES6&#39;, age: 2015 }) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;alias.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var js = { name: &#39;ES6&#39;, age: 2015 }

var { name: es, age } = js
// name, es, age?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;defaults.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var js = { name: &#39;ES6&#39;, age: 2015 }
var date = [2015, 9, 14]

var { version = &#39;6&#39; } = js
// version ?

var { fullname: f = &#39;ECMAScript 6&#39; } = js
// fullname, f ?

var [y, m, d, h = 9] = date
// y, m, d, h ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Default + Rest + Spread&lt;/p&gt;

&lt;p&gt;默认值、余下参数（Rest），数组展开（Spread）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认值： 减少了对输入参数的检查的代码量，即可读又简洁&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rest：对参数数组操作更加灵活&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spread：可以看作是 Rest 的反操作，更加方便对数组的操作&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  function bar (a) {
    a = a || 5
  }

  function sum (a) {
    a = a || 5
    var l = arguments.length
    var i = 1
    for (; i &amp;lt; l; ++i) {
      a += arguments[i]
    }
    return a
  }

  function apply () {
    function fn () {}
    var l = arguments.length
    var args = new Array(l)
    for (var i = 0; i &amp;lt; l; ++i) {
      args[i] = arguments[i]
    }
    fn.apply(null, args)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  function bar(a = 5) {
  }

  function sum (a = 5, ...args) {
    var l = args.length
    var i = 0
    for (; i &amp;lt; l; ++i) {
      a += args[i]
    }
    return a
  }

  function apply (...args) {
    function fn () {}
    fn.apply(null, args)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;string.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &#39;1234567890&#39;

// [...str] ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;concat.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = [1, 2, 3]
var b = [6, 5, 4]

var c = [...a, ...b]
// c ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;parse-args.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 解析参数，返回特定格式
 *
 * @return {Array} [arr, options, cb]
 */

function parseArgs (...args) {
  const last = args[args.length - 1]
  const type = typeof last
  let opts
  let cb

  if (&#39;function&#39; === type) {
    cb = args.pop()
    if (&#39;object&#39; === typeof args[args.length - 1]) {
      opts = args.pop()
    }
  } else if (&#39;object&#39; === type &amp;amp;&amp;amp; !Array.isArray(last)) {
    opts = args.pop()
  } else if (&#39;undefined&#39; === type) {
    args.pop()
    return parseArgs(...args)
  }

  if (Array.isArray(args[0])) {
    args = args[0]
  }
  return [args, opts || {}, cb]
}

// parseArgs(&#39;users&#39;) ?
// parseArgs(&#39;users&#39;, {}) ?
// parseArgs(&#39;users&#39;, () =&amp;gt; {}) ?
// parseArgs(&#39;users&#39;, {}, () =&amp;gt; {}) ?
// parseArgs(&#39;users&#39;, &#39;books&#39;) ?
// parseArgs([&#39;users&#39;, &#39;books&#39;]) ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Let + Const&lt;/p&gt;

&lt;p&gt;变量、常量定义声明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当满世界都是 &lt;code&gt;var&lt;/code&gt; 的时候，变量管理是个神坑！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;块级作用域&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const: 一次性声明&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  // 函数作用域下覆盖全局作用域
  var bar = 1
  var bar = 3
  function method () {
    console.log(bar) // undefined
    var bar = 2
  }

  // 变量泄漏
  var s = &#39;hello&#39;;
  for (var i = 0; i &amp;lt; s.length; i++) {
    console.log(s[i]);
  }
  console.log(i); // 5
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  let bar0 = 1
  let bar1 = 3

  function method () {
    console.log(bar0)
    let bar3 = 2
  }

  var s = &#39;hello&#39;;
  for (let i = 0; i &amp;lt; s.length; i++) {
    console.log(s[i]);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;global.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = 1
let b = 2
const c = 3

// this.a ?
// this.b ?
// this.c ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;for.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &#39;hello&#39;;
for (let i = 0; i &amp;lt; s.length; i++) {
  console.log(s[i]);
}
console.log(i); // ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Iterators + For..Of&lt;/p&gt;

&lt;p&gt;迭代器和 &lt;code&gt;for..of&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;像 &lt;code&gt;[...arr]&lt;/code&gt; 就是迭代器一个很好的例子。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可迭代协议：ES6 定义了一套统一的标准，允许对 JavaScript 对象自定义它们的迭代行为。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内置可迭代类型有 String，Array，TypedArray，Map，Set，因为在它们的原型对象上已经有了 &lt;code&gt;[Symbol.iterator]&lt;/code&gt; 方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  var arr = [1, 2, 3]

  for (let i in arr) {
    console.log(i)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  var arr = [1, 2, 3]

  for (let i of arr) {
    console.log(i)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;for-loops.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.prototype.arrCustom = function () {}
var arr = [1, 2, 3]
arr.isArray = true

for (let i in arr) {
  console.log(i) // ?
}

for (let i of arr) {
  console.log(i) // ?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;iterable.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next () {
        return {
          done: this.i === 10,
          value: this.i++
        }
      }
    }
  }
}

for (const i of iterable) {
  console.log(i) // ?
}

// [...iterable] ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;iterator.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next () {
        const done = this.i === 10
        const value = done ? undefined : this.i++
        return { done, value }
      }
    }
  }
}

const iterator = iterable[Symbol.iterator]()

iterator.next() // ?
iterator.next() // ?
iterator.next() // ?
// ...

const iterator2 = iterable[Symbol.iterator]()

iterator2.next() // ?
iterator2.next() // ?
iterator2.next() // ?
// ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generators&lt;/p&gt;

&lt;p&gt;生成器：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;生成器大杀器！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&#34;&gt;可迭代&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator&#34;&gt;遵循迭代器协议&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可在单个函数内 &lt;code&gt;GeneratorFunction&lt;/code&gt; 自定义迭代逻辑，可以替代迭代器，功能更强大&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可中断&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  var iterable = {
    [Symbol.iterator]() {
      return {
        i: 0,
        next () {
          const done = this.i === 10
          const value = done ? undefined : this.i++
          return { done, value }
        }
      }
    }
  }
  const iterator = iterable[Symbol.iterator]()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  function* generatable () {
    for (let i = 0, l = 10; i &amp;lt; l; ++i) {
      yield i
    }
  }
  const iterator = generatable()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;generatable.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* generatable () {
  for (let i = 0, l = 10; i &amp;lt; l; ++i) {
    yield i
  }
}
const iterator = generatable()

for (const i of generatable()) {
  console.log(i) // ?
}
// [...generatable()] ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;next.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* range(min = 0, max = 10, step = 1) {
  for (; min &amp;lt; max; min += step) {
    let rest = yield min
    if (rest) min = step * -1
  }
}

const iterator = range()

iterator.next() // ?
iterator.next() // ?
iterator.next() // ?
iterator.next(true) // ?
iterator.next() // ?
iterator.next() // ?
iterator.next() // ?

const iterator2 = range(0, 100, 2)

[...iterator2] // ?
iterator.next() // ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;return.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* range(min = 0, max = 10, step = 1) {
  for (; min &amp;lt; max; min += step) {
    let rest = yield min
    if (rest) min = step * -1
  }
}

const iterator = range()
iterator.next()
iterator.next(true)
iterator.next()
iterator.return() // ?
iterator.next() // ?
iterator.return(1) // ?
iterator.next() // ?
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;yield.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function* g() {
  yield 1
  yield 2
  yield 3
  yield* [4, 5, 6]
  yield* &#39;Hello World!&#39;
  yield 7
}

[...g()] // ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode&lt;/p&gt;

&lt;p&gt;Unicode&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;加强对 Unicode 的支持，并且扩展了字符串对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // same as ES5.1
  &amp;quot;𠮷&amp;quot;.length == 2

  // new RegExp behaviour, opt-in ‘u’
  &amp;quot;𠮷&amp;quot;.match(/./u)[0].length == 2

  // new form
  &amp;quot;\u{20BB7}&amp;quot; == &amp;quot;𠮷&amp;quot; == &amp;quot;\uD842\uDFB7&amp;quot;

  // new String ops
  &amp;quot;𠮷&amp;quot;.codePointAt(0) == 0x20BB7

  // for-of iterates code points
  for(var c of &amp;quot;𠮷&amp;quot;) {
    console.log(c);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modules ?&lt;/p&gt;

&lt;p&gt;模块话系统目前还未实现！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Subclassable Built-ins&lt;/p&gt;

&lt;p&gt;子类可继承自内置数据类型&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;真的太方便了，比如想对 Array 进行扩展，现在无需修改 &lt;code&gt;Array.prototype&lt;/code&gt;，&lt;code&gt;extends Array&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Array Boolean String Number Map Set Error RegExp Function Promise&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  // This is danger.
  Array.prototype.sum = function () {
    return this.reduce((t, curr) =&amp;gt; t + curr, 0)
  }

  var a = [1, 2, 3]
  a.sum()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  class CustomArray extends Array {
    constructor (...args) {
      super(...args)
    }

    sum () {
      return this.reduce((t, curr) =&amp;gt; t + curr, 0)
    }
  }

  var a = CustomArray.from([1, 2, 3])
  a.sum()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/trekjs/middleware&#34;&gt;middleware.js&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const SYMBOL_ITERATOR = Symbol.iterator

class Middleware extends Array {

  [SYMBOL_ITERATOR] () {
    return this
  }

  next (i = 0, context, nextFunc) {
    const fn = this[i] || nextFunc

    return {
      done: i === this.length,
      value: fn &amp;amp;&amp;amp; fn(context, () =&amp;gt; {
        return this.next(i + 1, context, nextFunc).value
      })
    }
  }

  compose (context, nextFunc) {
    return this[SYMBOL_ITERATOR]().next(0, context, nextFunc).value
  }

}

const middleware = new Middleware()

middleware.push((ctx, next) =&amp;gt; {
  ctx.arr.push(1)
  next()
  ctx.arr.push(6)
})

middleware.push((ctx, next) =&amp;gt; {
  ctx.arr.push(2)
  next()
  ctx.arr.push(5)
})

middleware.push((ctx, next) =&amp;gt; {
  ctx.arr.push(3)
  next()
  ctx.arr.push(4)
})

const ctx = { arr: [] }
middleware.compose(ctx)
console.log(ctx.arr) // ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Map + Set + WeakMap + WeakSet&lt;/p&gt;

&lt;p&gt;新增 &lt;code&gt;Map&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; &lt;code&gt;WeakMap&lt;/code&gt; &lt;code&gt;WeakSet&lt;/code&gt; 几种高效的数据类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // Sets
  var s = new Set();
  s.add(&amp;quot;hello&amp;quot;).add(&amp;quot;goodbye&amp;quot;).add(&amp;quot;hello&amp;quot;);
  s.size === 2;
  s.has(&amp;quot;hello&amp;quot;) === true;

  // Maps
  var m = new Map();
  m.set(&amp;quot;hello&amp;quot;, 42);
  m.set(s, 34);
  m.get(s) == 34;

  // Weak Maps
  var wm = new WeakMap();
  wm.set(s, { extra: 42 });
  wm.size === undefined

  // Weak Sets
  var ws = new WeakSet();
  ws.add({ data: 42 });
  // Because the added object has no other references, it will not be held in the set
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Proxies&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当我们不想把对象暴露出来，不想直接操作它们，想增加一层校验时，&lt;code&gt;Proxies&lt;/code&gt; 是一个最佳方案。&lt;br /&gt;
但当增加了 &lt;code&gt;Proxies&lt;/code&gt; 这一层，对性能还是会有影响的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  const inner = {
    name: &#39;ES6&#39;
  }

  var outer = {
    inner,
    get name () {
      return this.inner.name
    },
    set name (name) {
      this.inner.name = name
    }
  }

  // outer.name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  const inner = {
    name: &#39;ES6&#39;
  }

  var p = new Proxy(inner, {
    get (target, name) {
      return target[name]
    },

    set (target, name, value) {
      if (&#39;string&#39; !== typeof value) throw new TypeError(&#39;value must be String!&#39;)
      target[name] = value
    }
  })

  p.name
  p.name = 2
  p.name = &#39;ES2015&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/fundon/delegate-proxy&#34;&gt;delegate-proxy.js&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function delegateProxy (target, origin) {
  return new Proxy(target, {
    get (target, key, receiver) {
      if (key in target) return Reflect.get(target, key, receiver)
      const value = origin[key]
      return &#39;function&#39; === typeof value ? function method () {
        return value.apply(origin, arguments)
      } : value
    },
    set (target, key, value, receiver) {
      if (key in target) return Reflect.set(target, key, value, receiver)
      origin[key] = value
      return true
    }
  })
}

const bar = {
  n: 1,

  add (i) {
    this.n += i
  }
}

const foo = {

  set (n) {
    this.n = n | 0
  },

  sub (i) {
    this.n -= i
  }

}

const p = delegateProxy(foo, bar)

bar
foo
p

p.n       // ?
p.add(1)
p.n       // ?

p.sub(2)
p.n       // ?

p.set(1)
p.n       // ?

p.n = 233
p.n       // ?
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol&#34;&gt;Symbols&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;符号：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;唯一性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不可变&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不列入对象的 &lt;code&gt;Object.getOwnPropertyNames(obj)&lt;/code&gt; 和 &lt;code&gt;Object.keys(obj)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;想给对象打一个暗号，再也不难了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  let obj = {
    id: 1
  }

  obj.id      // 1
  obj.id = 2
  obj.id      // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  let obj = {
    [Symbol(&#39;id&#39;)]: 1
  }

  obj[Symbol(&#39;id&#39;)]      // undefined
  obj[Symbol(&#39;id&#39;)] = 2
  obj[Symbol(&#39;id&#39;)]      // undefined

  for (const k of Object.getOwnPropertySymbols(obj)) {
    console.log(obj[k])
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Math + Number + String + Array + Object APIs&lt;/p&gt;

&lt;p&gt;新增 APIs，数据操作更加方便。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  Number.EPSILON
  Number.isInteger(Infinity) // false
  Number.isNaN(&amp;quot;NaN&amp;quot;) // false

  Math.acosh(3) // 1.762747174039086
  Math.hypot(3, 4) // 5
  Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

  &amp;quot;abcde&amp;quot;.includes(&amp;quot;cd&amp;quot;) // true
  &amp;quot;abc&amp;quot;.repeat(3) // &amp;quot;abcabcabc&amp;quot;

  Array.from(document.querySelectorAll(&amp;quot;*&amp;quot;)) // Returns a real Array
  Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
  [0, 0, 0].fill(7, 1) // [0,7,7]
  [1,2,3].findIndex(x =&amp;gt; x == 2) // 1
  [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;].entries() // iterator [0, &amp;quot;a&amp;quot;], [1,&amp;quot;b&amp;quot;], [2,&amp;quot;c&amp;quot;]
  [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;].keys() // iterator 0, 1, 2
  [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;].values() // iterator &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;

  Object.assign(Point, { origin: new Point(0,0) })
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary and Octal Literals&lt;/p&gt;

&lt;p&gt;二进制 &lt;code&gt;b&lt;/code&gt;，八进制 &lt;code&gt;o&lt;/code&gt; 字面量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  0b111110111 === 503 // true
  0o767 === 503 // true
  0x1f7 === 503 // true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Promises&lt;/p&gt;

&lt;p&gt;Promises：更加优雅的异步编程方式。想更加清晰了解 &lt;code&gt;Promise&lt;/code&gt; 的执行过程，可以看这个可视化工具 &lt;a href=&#34;https://github.com/bevacqua/promisees&#34;&gt;promisees&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面对异步编程，&lt;code&gt;callback-hell&lt;/code&gt; 就是 JavaScript 给人的最大诟病！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // old
  getProfileById(233, (err, res) =&amp;gt; {
    if (err) throw err
    getFollowing(233, (err, following) =&amp;gt; {
      if (err) throw err
      getFollowers(233, (err, followers) =&amp;gt; {
        if (err) throw err
        getStarred(233, (err, starred) =&amp;gt; {
          if (err) throw err
          // ....
        })
      })
    })
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // new
  getProfileById(233)
    .then(res =&amp;gt; getFollowing(233))
    .then(res =&amp;gt; getFollowers(233))
    .then(res =&amp;gt; getStarred(233))
    .catch(err =&amp;gt; console.log(err))
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猜猜猜&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;simple-promise.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function loadImage (url) {
  return new Promise((resolve, reject) =&amp;gt; {
    const img = new Image()

    img.onload = function () {
      resolve(img)
    }

    img.onerror = function () {
      reject(new Error(&#39;Could not load image at &#39; + url))
    }

    img.url = url
  })
}

loadImage(&#39;https://nodejs.org/static/images/logo-header.png&#39;)
  .then(img =&amp;gt; document.body.appendChild(img))
  .catch(err =&amp;gt; console.log(err))
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;all.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function delay(value, duration = 0) {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; resolve(value), duration)
  })
}

let res = Promise.all([
  delay(10, 1),
  delay(8, 2),
  delay(6, 3),
  delay(4, 4),
  delay(2, 5),
  delay(0, 6),
])

res.then(arr =&amp;gt; {
  console.log(arr) // ?
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;race.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function delay(value, duration = 0) {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; resolve(value), duration)
  })
}

let res = Promise.race([
  delay(10, 1),
  delay(8, 2),
  delay(6, 3),
  delay(4, 4),
  delay(2, 5),
  delay(0, 6),
])

res.then(arr =&amp;gt; {
  console.log(arr) // ?
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;reduce.js&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const reduce = (arr, cb, initialValue = 0) =&amp;gt; {
  return arr.reduce(cb, Promise.resolve(initialValue))
}

const cb = (prev, curr) =&amp;gt; prev.then(v =&amp;gt; v + curr)

reduce([1, 2, 3, 4, 5, 6, 7, 8, 9], cb)
  .then(res =&amp;gt; {
    console.log(res) // ?
  })
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&#34;&gt;Reflect API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;反射 API：公开了对象的元操作，效果跟 Proxy API 相反&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;e.g.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var O = {a: 1};
  Object.defineProperty(O, &#39;b&#39;, {value: 2});
  O[Symbol(&#39;c&#39;)] = 3;

  Reflect.ownKeys(O); // [&#39;a&#39;, &#39;b&#39;, Symbol(c)]

  function C(a, b){
    this.c = a + b;
  }
  var instance = Reflect.construct(C, [20, 22]);
  instance.c; // 42
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tail Calls&lt;/p&gt;

&lt;p&gt;优化了尾递归算法，保证栈不会无限增长，使得尾递归算法安全。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;快速体验&#34;&gt;快速体验&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;对以上新特性，快速体验一番，环境包括 浏览器 和 Node.js&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;高级应用&#34;&gt;高级应用&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;深入学习特性，应用生产&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;兼容-代码转换&#34;&gt;兼容，代码转换&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;使用转换工具，对 ES6+ 的代码进行转换，适配浏览器或者 Node &amp;lt; v6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://es6.ruanyifeng.com&#34;&gt;http://es6.ruanyifeng.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/lukehoban/es6features&#34;&gt;https://github.com/lukehoban/es6features&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://babeljs.io/docs/learn-es2015/&#34;&gt;https://babeljs.io/docs/learn-es2015/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ponyfoo.com/articles/tagged/es6-in-depth&#34;&gt;https://ponyfoo.com/articles/tagged/es6-in-depth&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/bevacqua/es6&#34;&gt;https://github.com/bevacqua/es6&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/DrkSephy/es6-cheatsheet&#34;&gt;https://github.com/DrkSephy/es6-cheatsheet&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ericdouglas/ES6-Learning&#34;&gt;https://github.com/ericdouglas/ES6-Learning&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/addyosmani/es6-tools&#34;&gt;https://github.com/addyosmani/es6-tools&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/bevacqua/promisees&#34;&gt;https://github.com/bevacqua/promisees&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;

&lt;p&gt;授权：&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34;&gt;署名-非商业性使用&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://fundon.me&#34;&gt;fundon.me&lt;/a&gt; &amp;nbsp;&amp;middot;&amp;nbsp;
GitHub &lt;a href=&#34;https://github.com/fundon&#34;&gt;@fundon&lt;/a&gt; &amp;nbsp;&amp;middot;&amp;nbsp;
Twitter &lt;a href=&#34;https://twitter.com/_fundon&#34;&gt;@_fundon&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>10 Habits of a Happy Node Hacker 2016</title>
      <link>https://fundon.me/blog/10-Habits-of-a-Happy-Node-Hacker-2016/</link>
      <pubDate>Sat, 12 Dec 2015 22:22:46 +0800</pubDate>
      
      <guid>https://fundon.me/blog/10-Habits-of-a-Happy-Node-Hacker-2016/</guid>
      <description>

&lt;p&gt;原文：&lt;a href=&#34;https://blog.heroku.com/archives/2015/11/10/node-habits-2016&#34;&gt;10 Habits of a Happy Node Hacker (2016)&lt;/a&gt; by Hunter&lt;/p&gt;

&lt;p&gt;在 2015 年底，JavaScript 开发者周边已经充斥了很多工具，供他们支配使用。
&lt;a href=&#34;https://blog.heroku.com/archives/2014/3/11/node-habits&#34;&gt;上次&lt;/a&gt;我们已经观察了这个问题，现代 JS 的兴起。今天，我们很容易迷失在这巨大的生态系统中，
所以成功的团队都需要遵循指南，使他们的时间和项目保存健康。&lt;/p&gt;

&lt;p&gt;这 10 个习惯很适合即将进入 2016 的 Node.js 黑客。
它们真对的是应用开发者，而不是模块作者，因为这些群体有不同的目标和约束：&lt;/p&gt;

&lt;h2 id=&#34;1-使用-npm-init-开始每个新项目&#34;&gt;1. 使用 &lt;code&gt;npm init&lt;/code&gt; 开始每个新项目&lt;/h2&gt;

&lt;p&gt;NPM &lt;code&gt;init&lt;/code&gt; 命令将为你的项目生成一个有效的 &lt;code&gt;package.json&lt;/code&gt; 文件，
从工作目录中自动推到出一些常见属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir my-awesome-app
$ cd my-awesome-app
$ npm init --yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我比较懒，所以我使用了 &lt;code&gt;--yes&lt;/code&gt; 标志去执行它，然后打开 package.json 做些修改。
第一件事你应该指定一个 &lt;code&gt;engines&lt;/code&gt; 关键词，使用你当前的 node 版本（&lt;code&gt;node -v&lt;/code&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;engines&amp;quot;: {
  &amp;quot;node&amp;quot;: &amp;quot;4.2.1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-使用一个智能的-npmrc-配置&#34;&gt;2. 使用一个智能的 &lt;code&gt;.npmrc&lt;/code&gt; 配置&lt;/h2&gt;

&lt;p&gt;默认地，npm 不会保存已经安装的依赖到 package.json（所以你总是需要追踪你的依赖！）。&lt;/p&gt;

&lt;p&gt;如果你使用 &lt;code&gt;--save&lt;/code&gt; 标志去自动更新 package.json，npm 安装这些包会以 &lt;code&gt;^&lt;/code&gt; 开头，会导致你的
模块在不同版本之间漂移。这对模块开发没问题，但对应用不好，
如果你想要在所有的环境之间保持一致的依赖关系。&lt;/p&gt;

&lt;p&gt;一个解决方案是像这样安装包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install foobar --save --save-exact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更胜一筹的，你可以把这些选项添加到 &lt;code&gt;~/.npmrc&lt;/code&gt; 中，更新你的默认设置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm config set save=true
$ npm config set save-exact=true
$ cat ~/.npmrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，&lt;code&gt;npm install foobar&lt;/code&gt; 将会自动添加 &lt;code&gt;foobar&lt;/code&gt; 到 package.json
并且你的依赖不会在安装时产生偏移!&lt;/p&gt;

&lt;p&gt;如果你更喜欢在 package.json 中保持弹性依赖，但仍然需要在生产环境中锁住依赖的话，你或者可以
生成 &lt;a href=&#34;https://docs.npmjs.com/cli/shrinkwrap&#34;&gt;npm&amp;rsquo;s shrinkwrap&lt;/a&gt; 到你的工作流中。这需要花费更多的精力，但是还是很多好处的，保持
准确的版本的嵌套依赖关系。&lt;/p&gt;

&lt;h2 id=&#34;3-快跳上-es6-火车吧&#34;&gt;3. 快跳上 ES6 火车吧！&lt;/h2&gt;

&lt;p&gt;Node 4+ 携带了一个 &lt;a href=&#34;https://nodejs.org/en/blog/release/v4.0.0/&#34;&gt;V8 引擎的更新&lt;/a&gt;，拥有几个有用的 &lt;a href=&#34;https://nodejs.org/en/docs/es6/&#34;&gt;ES6 特性&lt;/a&gt;。
不要害怕，并不是一些复杂的东西，你可以轻松学习它。有许多简单的改进，让人满意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let user = users.find(u =&amp;gt; u.id === ID);

console.log(`Hello, ${ user.name }!`);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-坚持使用小写&#34;&gt;4. 坚持使用小写&lt;/h2&gt;

&lt;p&gt;一些语言鼓励文件名匹配类名，比如 &lt;code&gt;MyClass&lt;/code&gt; 和 &lt;code&gt;MyClass.js&lt;/code&gt;。在 Node 中，
不要那样做。而是使用文件名小写的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let MyClass = require(&#39;my-class&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js 是一个罕见的范例，Linux-centric 化工具，但跨平台支持又多。
当在 OSX 和 Windows 平台时，对待 &lt;code&gt;myclass.js&lt;/code&gt; 和 &lt;code&gt;MyClass.js&lt;/code&gt; 是一样的，
Linux 不会。如果要编写可在这些平台移植的代码，你就需要明确匹配 &lt;code&gt;require&lt;/code&gt;
中的声明，包括大写。&lt;/p&gt;

&lt;p&gt;一个简单正确的方式，就是一切都使用文件名小写的方式。例如 &lt;code&gt;my-class.js&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;译者：其实 Mac OSX 也可以设置文件系统 case-sensitive。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;5-cluster-你的应用&#34;&gt;5. Cluster 你的应用&lt;/h2&gt;

&lt;p&gt;自从 node 运行时被限制在单核 CPU 和大约 1.5 GB 的内存之后，
部署一个无 clustered 模式的 node 应用在一个大型服务器上是一个对资源巨大的浪费。&lt;/p&gt;

&lt;p&gt;要想利用多核和内存超过 1.5 GB 的话，把支持 &lt;a href=&#34;https://nodejs.org/api/cluster.html&#34;&gt;Cluster&lt;/a&gt; 烧尽你的应用。
即使如果今天你仅仅把单个进程运行在小硬件上，在未来 Cluster 也会带给你足够的灵活。&lt;/p&gt;

&lt;p&gt;测试是最好的方式，弄清楚你的应用理想的 clustered 进程数，
但最好根据你的平台提出一个&lt;a href=&#34;https://devcenter.heroku.com/articles/node-concurrency&#34;&gt;合理的默认值&lt;/a&gt;，可以有个简单的备选。
比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const CONCURRENCY = process.env.WEB_CONCURRENCY || 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择一个 &lt;a href=&#34;https://www.npmjs.com/search?q=cluster&#34;&gt;Cluster abstraction&lt;/a&gt; 可以避免重复造（进程管理的）轮子。如果你喜欢分开
&lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;worker&lt;/code&gt; 文件，可以试试 &lt;a href=&#34;https://www.npmjs.com/package/forky&#34;&gt;forky&lt;/a&gt;。 如果你更喜欢单个入口文件和函数的话，
看看这个 &lt;a href=&#34;https://www.npmjs.com/package/throng&#34;&gt;throng&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;6-有环境意识&#34;&gt;6. 有环境意识&lt;/h2&gt;

&lt;p&gt;不要在你的项目中乱扔具体环境配置文件！而应该使用环境变量。&lt;/p&gt;

&lt;p&gt;首选，安装 &lt;a href=&#34;https://github.com/strongloop/node-foreman&#34;&gt;node-foreman&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install --save --save-exact foreman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，创建一个 &lt;a href=&#34;https://devcenter.heroku.com/articles/procfile&#34;&gt;Procfile&lt;/a&gt; 文件，声明你的应用的进程类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web: bin/web
worker: bin/worker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，你就可以使用 &lt;code&gt;nf&lt;/code&gt; 程序启动你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;start&amp;quot;: &amp;quot;nf start&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要支持本地开发环境，可以创建 &lt;code&gt;.gitignore&lt;/code&gt; 文件，把 &lt;code&gt;.env&lt;/code&gt; 文件加入进来。
使用 node-foreman 时，&lt;code&gt;.env&lt;/code&gt; 文件将会被加载进来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;DATABASE_URL=&#39;postgres://localhost/foobar&#39;
HTTP_TIMEOUT=10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，一个简单的命令（&lt;code&gt;npm start&lt;/code&gt;）将会使 &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;worker&lt;/code&gt; 进程在那个环境下
同时运转起来。然后，当你部署你的项目时，它会在新的主机上自动适应这些环境变量。&lt;/p&gt;

&lt;p&gt;比起 &lt;code&gt;config/abby-dev.js&lt;/code&gt;、&lt;code&gt;config/brian-dev.js&lt;/code&gt;，&lt;code&gt;config/qa1.js&lt;/code&gt;、
&lt;code&gt;config/qa2.js&lt;/code&gt;、&lt;code&gt;config/prod.js&lt;/code&gt;，这个更加简单灵活。&lt;/p&gt;

&lt;h2 id=&#34;7-避免垃圾回收&#34;&gt;7. 避免垃圾回收&lt;/h2&gt;

&lt;p&gt;Node（V8）使用一个懒惰、贪婪的垃圾回收。它默认被限制在大约 1.5 GB。
在回收无用内存前，它有时会等待，直到它彻底回收这些无用内存。如果你的内存使用不断增加，
它可能不是内存泄漏，反而是 &lt;a href=&#34;https://github.com/nodejs/node/issues/3370#issuecomment-148108323&#34;&gt;node 通常的懒惰行为&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要想对你应用的垃圾回收获得更多的控制，你可以在你的 &lt;code&gt;Procfile&lt;/code&gt; 文件中给 V8 添加一些标志：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web: node --optimize_for_size --max_old_space_size=920 --gc_interval=100 server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个尤其重要，如果你的应用是运行在一个少于 1.5 GB 内存的环境上。
例如，你想要把 node 调整到一个 512 MB 的容器上，试试这个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web: node --optimize_for_size --max_old_space_size=460 --gc_interval=100 server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-把事情链接起来&#34;&gt;8. 把事情链接起来&lt;/h2&gt;

&lt;p&gt;Npm 的&lt;a href=&#34;https://docs.npmjs.com/misc/scripts&#34;&gt;生命周期脚本&lt;/a&gt; 可以为自动化创建丰富的钩子。如果你需要在构建你的应用之前运行一些东西，
你可以使用 &lt;code&gt;preinstall&lt;/code&gt; 脚本。如果想使用 grunt、gulp、browserify 或者 webpack 构建
assets 呢？那就使用 &lt;code&gt;postinstall&lt;/code&gt; 脚本。&lt;/p&gt;

&lt;p&gt;在 package.json 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;postinstall&amp;quot;: &amp;quot;bower install &amp;amp;&amp;amp; grunt build&amp;quot;,
  &amp;quot;start&amp;quot;: &amp;quot;nf start&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以使用环境变量去控制这些脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;postinstall&amp;quot;: &amp;quot;if $BUILD_ASSETS; then npm run build-assets; fi&amp;quot;,
&amp;quot;build-assets&amp;quot;: &amp;quot;bower install &amp;amp;&amp;amp; grunt build&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的脚本想在外面进行控制的话，把它们移到相应的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;postinstall&amp;quot;: &amp;quot;scripts/postinstall.sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 &lt;code&gt;./node_modules/.bin&lt;/code&gt; 会被自动添加到环境变量 &lt;code&gt;PATH&lt;/code&gt; 上，在 package.json 中的脚本
会从上面去寻找，所以你可以直接执行它们，就像 &lt;code&gt;bower&lt;/code&gt; 或者 &lt;code&gt;wepack&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;9-仅-git-重要的部分&#34;&gt;9. 仅 git 重要的部分&lt;/h2&gt;

&lt;p&gt;大多数的应用是由必要的文件和生成文件组成。当使用一个版本控制系统像 git 时，你应该避免对生成的
任何文件都进行追踪。&lt;/p&gt;

&lt;p&gt;例如，你的 node 应用可能会有一个 &lt;code&gt;node_modules&lt;/code&gt; 依赖目录，这个你应该&lt;a href=&#34;https://docs.npmjs.com/misc/faq#should-i-check-my-node-modules-folder-into-git&#34;&gt;避免 git 控制&lt;/a&gt;。
只要每个依赖都列在 package.json 文件中，任何人都可以创建一个你的应用的工作副本，包括
&lt;code&gt;node_modules&lt;/code&gt; － 在运行 &lt;code&gt;npm install&lt;/code&gt; 后。&lt;/p&gt;

&lt;p&gt;追踪这些生成文件，将会导致你的 git 历史充斥着无用的声音和臃肿。这是非常糟糕的，自从有些依赖是
原生并且需要被编译时，检查它们将使你的应用缺少便捷性，因为你将需要提供多个编译版本，
但却只从一个、可能是不正确的环境中生成。&lt;/p&gt;

&lt;p&gt;同样的原因，你也不应该检查 &lt;code&gt;bower_components&lt;/code&gt; 或者由 grunt 编译生成的 assets。&lt;/p&gt;

&lt;p&gt;如果你之前已经不慎检查了 &lt;code&gt;node_modules&lt;/code&gt; 目录，没关系，你可以删掉它，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo &#39;node_modules&#39; &amp;gt;&amp;gt; .gitignore
$ git rm -r --cached node_modules
$ git commit -am &#39;ignore node_modules&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我也忽略了 npm 的 logs 文件，所以它们不会搞乱我的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo &#39;npm-debug.log&#39; &amp;gt;&amp;gt; .gitignore
$ git commit -am &#39;ignore npm-debug&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;忽略了这些无用的文件，你的仓库将会更加的小，你的提交将会更加简单，
并且你将避免合并这些因生成目录而导致的分歧。&lt;/p&gt;

&lt;h2 id=&#34;10-简约&#34;&gt;10. 简约&lt;/h2&gt;

&lt;p&gt;技术预测是不准确的，但我还是会预测下即将到来的一年，2016 将是 JavaScript 简化的一年。&lt;/p&gt;

&lt;p&gt;越来越多的开发者正在简化它们的架构。为替换庞大的 MVCs 框架，他们正在使用&lt;a href=&#34;https://medium.com/swlh/scaling-on-the-cheap-933e46944886#.2lvubkyhm&#34;&gt;静态化的前端构建项目&lt;/a&gt;，
这样可以部署在 CDN 上，且使用一个 Node.js API 提供动态数据。&lt;/p&gt;

&lt;p&gt;我们也开始看到了复杂的构建系统对我们项目的阻力。一些前沿的开发者正在简化他们的构建系统。例如，
使用一个 &lt;code&gt;vanilla&lt;/code&gt; 构建系统，没有 &lt;a href=&#34;https://medium.com/@tarkus/you-might-not-need-gulp-js-89a0220487dd#.etiox78kw&#34;&gt;bower、gulp 或者 grunt&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最终，我们将简化我们的代码在 2016。有时，这来自删除功能，
就像 &lt;a href=&#34;https://www.youtube.com/watch?v=bo36MrBfTk4&#34;&gt;Douglas Crockford&amp;rsquo;s &amp;ldquo;The Better Parts&amp;rdquo;&lt;/a&gt;。
其他，这来自添加功能 － 就像我喜欢的 callback 的替代物 &lt;a href=&#34;https://thomashunter.name/blog/the-long-road-to-asyncawait-in-javascript/&#34;&gt;async-await&lt;/a&gt;。
Async-await 在 Node 中还不能用，但今天你可以借助牛逼的 &lt;a href=&#34;http://babeljs.io/docs/usage/cli/#babel-node&#34;&gt;Babeljs&lt;/a&gt; 项目使用它。&lt;/p&gt;

&lt;p&gt;不要把看到那么多工具和框架一次性都挤进你的项目，试着去简化你的工作。&lt;/p&gt;

&lt;h2 id=&#34;你的习惯是什么&#34;&gt;你的习惯是什么？&lt;/h2&gt;

&lt;p&gt;我试着在我的所有项目中遵从这些习惯。不管你是 &lt;a href=&#34;https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction&#34;&gt;node 新人&lt;/a&gt;还是服务端 JS 老手，我确定你会为
自己开发一些技巧。我们非常欢迎听到它们！使用 &lt;a href=&#34;https://twitter.com/search?f=tweets&amp;amp;vertical=default&amp;amp;q=%23node_habits&amp;amp;src=typd&#34;&gt;#node_habits&lt;/a&gt; 标签，分享你的习惯！&lt;/p&gt;

&lt;p&gt;Happy hacking!&lt;/p&gt;

&lt;p&gt;本文由 fundon 翻译，未经许可，不得转载。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Docker Compose in Node.js Project</title>
      <link>https://fundon.me/web/Using-Docker-Compose-in-Node.js-Project/</link>
      <pubDate>Thu, 26 Nov 2015 02:42:34 +0800</pubDate>
      
      <guid>https://fundon.me/web/Using-Docker-Compose-in-Node.js-Project/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://medium.com/@fundon/using-docker-compose-in-node-js-project-65081953ce62#.3h17cxx5v&#34;&gt;Published on Medium&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;docker-到底有什么优点吸引我们&#34;&gt;Docker 到底有什么优点吸引我们？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Build&lt;/strong&gt;：允许自由组合各种服务来构建我们的应用，避免&lt;strong&gt;开发&lt;/strong&gt;和&lt;strong&gt;生产&lt;/strong&gt;之间的环境问题，并且不局限在任何平台和语言&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ship&lt;/strong&gt;：通过统一的用户接口，管理，设计应用开发、测试、发布的生命周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run&lt;/strong&gt;：可以快捷地在多个平台，发布可扩展、安全、可靠的服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;use-it&#34;&gt;Use it!&lt;/h3&gt;

&lt;p&gt;说了这么多，那就让我们玩起来！&lt;/p&gt;

&lt;h4 id=&#34;0-install-docker-tools&#34;&gt;0. Install &lt;a href=&#34;https://docs.docker.com&#34;&gt;Docker&lt;/a&gt; Tools&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ brew install docker docker-machine docker-compose
$ docker help
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com&#34;&gt;Docker&lt;/a&gt; - 开源的容器应用引擎&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Machine&lt;/a&gt; - 管理本地、云服务提供商中的 Docker 服务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Compose&lt;/a&gt; - 定义，组合，运行多个容器应用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果是 Mac OS X 用户，请先安装 Virtualbox &lt;code&gt;brew cask install virtualbox&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果不喜欢 Docker CLI 工具，也可以安装 &lt;a href=&#34;https://docs.docker.com/kitematic/&#34;&gt;Kitematic&lt;/a&gt;，Kitematic 是 Docker 的 GUI 管理工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-create-node-js-project&#34;&gt;1. Create Node.js Project&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir docker-express-mongoose-reis-example
$ cd docker-express-mongoose-redis-example
$ npm init
$ npm i express express-session connect-redis ioredis mongoose --save
$ touch server.js 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;server.js&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Import modules
const express = require(&#39;express&#39;)
const session = require(&#39;express-session&#39;)
const ioredis = require(&#39;ioredis&#39;)
const RedisStore = require(&#39;connect-redis&#39;)(session)
const mongoose = require(&#39;mongoose&#39;)

// Create App
const app = express()

// Redis Client
const client = ioredis.createClient(6379, process.env.REDIS_PORT_6379_TCP_ADDR)

// Compose Schema
const ComposeSchema = new mongoose.Schema({
  name:  String,
  build: String,
  ports: [String]
})

// Compose Model
const Compose = mongoose.model(&#39;Compose&#39;, ComposeSchema) 

// Create Session
app.use(session({
  store: new RedisStore({ client }),
  secret: &#39;Dream&#39;
}))

// Routes for redis
app.get(&#39;/redis&#39;, (req, res) =&amp;gt; {
  res.send(&#39;Redis is live!&#39;)
})
app.get(&#39;/redis/set&#39;, (req, res) =&amp;gt; {
  client.set(&#39;key&#39;, &#39;Redis is live!&#39;);
  res.send(`It&#39;s redis.`)
})
app.get(&#39;/redis/get&#39;, (req, res) =&amp;gt; {
  client.get(&#39;key&#39;).then(result =&amp;gt; {
    res.send(result || &#39;Nothing!&#39;)
  })
})

// Routes for redis
app.get(&#39;/mongoose&#39;, (req, res) =&amp;gt; {
  res.send(&#39;Mongoose is live!&#39;)
})
app.get(&#39;/mongoose/set&#39;, (req, res) =&amp;gt; {
  var c = new Compose({
    name: &#39;docker&#39;,
    build: &#39;.&#39;,
    ports: [&#39;3000:3000&#39;]
  })

  c.save().then(() =&amp;gt; {
      res.send(`It&#39;s mongoose.`);
    })
})
app.get(&#39;/mongoose/get&#39;, (req, res) =&amp;gt; {
  Compose
    .find({ name: &#39;docker&#39; })
    .then((result) =&amp;gt; {
      res.send(result)
    })
})

app.use((req, res) =&amp;gt; {
  res.send(&#39;Hello Docker, Express, Mongoose, Redis!&#39;)
})

mongoose.connect(`mongodb://${process.env.MONGO_PORT_27017_TCP_ADDR}`, (err) =&amp;gt; {
  if (err) throw err

  // Start App
  app.listen(process.env.PORT || 3000)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;package.json&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;docker-express-mongoose-redis-example&amp;quot;,
  &amp;quot;private&amp;quot;: true,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node server.js&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;connect-redis&amp;quot;: &amp;quot;^3.0.1&amp;quot;,
    &amp;quot;express&amp;quot;: &amp;quot;^4.13.3&amp;quot;,
    &amp;quot;express-session&amp;quot;: &amp;quot;^1.11.3&amp;quot;,
    &amp;quot;ioredis&amp;quot;: &amp;quot;^1.9.1&amp;quot;,
    &amp;quot;mongoose&amp;quot;: &amp;quot;^4.2.0&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-machine-在-virtualbox-中创建-docker-host&#34;&gt;2. &lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Machine&lt;/a&gt;：在 virtualbox 中创建 Docker Host&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ # 查看命令行帮助
$ docker-machine
$ # 创建 Docker Host
$ docker-machine create -d virtualbox dev
$ # 启动
$ docker-machine start dev
$ # 查看 dev IP
$ docker-machine ip dev
$ # 查看 dev 环境变量
$ docker-machine env dev
$ # 设置环境变量
$ eval &amp;quot;$(docker-machine env dev)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-compose-定义及操作&#34;&gt;3. &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Compose&lt;/a&gt;：定义及操作&lt;/h4&gt;

&lt;h5 id=&#34;为项目创建-dockerfile&#34;&gt;为项目创建 &lt;a href=&#34;https://docs.docker.com/reference/builder/&#34;&gt;Dockerfile&lt;/a&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cd docker-express-mongoose-redis-example
$ touch Dockerfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Dockerfile&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM mhart/alpine-node
# FROM mhart/alpine-node:base
# FROM mhart/alpine-node:base-0.10

WORKDIR /src
ADD . .

# If you have native dependencies, you&#39;ll need extra tools
RUN apk add --update make gcc g++ python

# If you need npm, don&#39;t use a base tag
RUN npm install

# If you had native dependencies you can now remove build tools
RUN apk del make gcc g++ python &amp;amp;&amp;amp; \
  rm -rf /tmp/* /var/cache/apk/* /root/.npm /root/.node-gyp

EXPOSE 3000
CMD [&amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;创建-docker-compose-yml-来组合-node-js-redis-mongodb-服务&#34;&gt;创建 &lt;a href=&#34;https://docs.docker.com/compose/yml&#34;&gt;docker-compose.yml&lt;/a&gt; 来组合 Node.js, Redis, Mongodb 服务&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cd docker-express-mongoose-redis-example
$ touch docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Dockerfile&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;app:
  build: .
  volumes:
    - .:/src
  links:
    - mongo
    - redis
  ports:
    - 3000:3000

redis:
  image: redis

mongo:
  image: mongo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ # 查看命令行帮助
$ docker-compose
$ # 创建
$ docker-compose build
$ # 启动 app, redis, mongo 等服务，特点是常驻前台
$ docker-compose up
$ # 也可以通过 `start` 启动，特点是常驻在后台
$ docker-compose start
$ # 停止服务
$ docker-compose stop
$ # 输出日志
$ docker-compose logs
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;测试-访问我们的服务-rocket&#34;&gt;测试、访问我们的服务 :rocket:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ open &amp;quot;http://$(docker-machine ip dev):3000&amp;quot;
$ open &amp;quot;http://$(docker-machine ip dev):3000/redis&amp;quot;
$ open &amp;quot;http://$(docker-machine ip dev):3000/redis/set&amp;quot;
$ open &amp;quot;http://$(docker-machine ip dev):3000/redis/get&amp;quot;
$ open &amp;quot;http://$(docker-machine ip dev):3000/mongoose&amp;quot;
$ open &amp;quot;http://$(docker-machine ip dev):3000/mongoose/set&amp;quot;
$ open &amp;quot;http://$(docker-machine ip dev):3000/mongoose/get&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;关闭服务-休息下&#34;&gt;关闭服务，休息下&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ docker-compose stop
$ docker-machine stop dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Compose 的前身是 &lt;strong&gt;fig&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;up&lt;/code&gt; &lt;code&gt;start&lt;/code&gt; &lt;code&gt;logs&lt;/code&gt; &lt;code&gt;stop&lt;/code&gt; &lt;code&gt;rm&lt;/code&gt; 等 COMMANDs 可以针对某个 Container 使用 e.g: &lt;code&gt;$ docker-compose logs app&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果 Node 项目比较大，依赖的模块较多，频繁改动，我们可以不需要创建 Node 项目本身的 Container，只需要创建启动其他服务即可。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;其他工具&#34;&gt;其他工具&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vagrantup.com&#34;&gt;Vargant&lt;/a&gt; - 也是一款环境构建工具，比 Docker 还早&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vargant 是一款不错的工具，可以帮助我们快速搭建各种服务环境，也能团队之间进行分享，现在基于它的工具链也越来越丰富，感兴趣也可以一试。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不用其他构建工具，我们自己搭&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“自己动手，丰衣足食” － 不依赖环境构建工具，自己搭，时间精力充足的化，不妨一试，会收获更多。&lt;/p&gt;

&lt;h3 id=&#34;最后&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;Docker 可玩的不仅仅如此，还可以打包、发布容器应用到线上，构建自己的 Paas(&lt;a href=&#34;https://github.com/progrium/dokku&#34;&gt;dokku&lt;/a&gt;) 服务等。&lt;/p&gt;

&lt;p&gt;Docker Compose 也可以有更高级玩法。&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  github: &#39;@fundon&#39;,
  email: &#39;cfddream#gmail.com&#39;,
  twitter: &#39;@_fundon&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;relates&#34;&gt;Relates&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/kitematic/&#34;&gt;https://docs.docker.com/kitematic/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/installation/mac/&#34;&gt;https://docs.docker.com/installation/mac/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/machine/install-machine/&#34;&gt;https://docs.docker.com/machine/install-machine/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;https://docs.docker.com/compose/install/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mhart/alpine-node&#34;&gt;https://github.com/mhart/alpine-node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/progrium/dokku&#34;&gt;https://github.com/progrium/dokku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>